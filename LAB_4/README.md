# LAB 4

---

## Задание 1
### Поиск подстроки в строке

- На вход поступают `p` - подстрока и `t` - основная строка
- Чтобы эффективно решить задачу на поиск подстроки воспользуюсь алгоритмом Кнута-Морриса-Пратта `kmp` (КМП)
- КМП в свою очередь использует Префикс-Функцию `prefix-function`

#### Как работает `prefix_function`

- создает список `pi`, в котором для каждой позиции строки `s` хранится длина наибольшего префикса, совпадающего с суффиксом, заканчивающимся в этой позиции.
- Проходится по строке от `i = 1` и берет за `k` - "предыдущую длину префикса, совпадающего с суффиксом" `pi[i-1]`
- если символы в строке с индексами `i` и `k` не совпадают, то откатываемся назад по списку `p = [k - 1]`, до 0-ля
- если символы совпадают, увеличиваем `k`
- тоесть `k` - количество совпадений префикса и суффикса подряд
- добавляем `k` в список `p`

```python
def prefix_function(s):
    pi = [0]
    for i in range(1, len(s)):
        k = pi[i - 1]
        while k > 0 and s[i] != s[k]:
            k = pi[k - 1]
        if s[i] == s[k]:
            k += 1
        pi.append(k)
    print(pi)
    return pi
```

#### как работает `kmp`
- соединяем подстроку и строку с помощью сивмвола, который не встретится в строке или подстроке, например `#`
- проходимся по списку `pi` из префикс функции 
- если встречаем количество совпадений, равное длине нашей подстроки, то добавляем его индекс, начиная со строки `t`

```python
def kmp(p, t):
    s = p + "#" + t
    pi = prefix_function(s)
    result = []
    len_p = len(p)
    len_s = len(s)
    for i in range(len_p + 1, len_s):
        print(s[i])
        if pi[i] == len_p:
            result.append(i - (len_p + 2))
    return result
```

ИТОГ: время работы алгоритма = `О(n + m)`
- где `n` - длина текста `t`
- `m` - длина шаблона `p`
- иначе говоря, `n + m` - `s` длина объедененной строки по алгоритму КМП

---
## Задание 4
### (Равенство подстрок) с использованием полиномиального хеширования

- `compute_hashes` — вычисляет *`префиксные хеши`* и степени `x`.
- `substring_hash` — возвращает хеш подстроки за `O(1)`.
- Используется `двойное хеширование`, чтобы избежать коллизий.

### префиксные хэши
Префиксный хеш `h[i]` — это хеш от начала строки до символа `i-1`. То есть `h[i] = H(s[0..i-1])`

#### Функция `compute_hashes`
- Чтобы вычислять быстро хеш подстроки, мы будем:
  - Хранить `префиксные хеши` для всех индексов - список `h`.
  - Хранить предвычисленные степени `x (x^i)` - список `x_pows`.
- функция для посчета префиксного хэша `h[i] = (x * h[i - 1] + ord(s[i - 1])) % m`
  - `h[1] = ord(s[0])`
  - `h[2] = x·ord(s[0]) + ord(s[1])`
  - `h[3] = x²·ord(s[0]) + x·ord(s[1]) + ord(s[2])`
  - где `ord(s[i - 1])` — преобразует символ в число (ASCII-код).
  - делим на m(модуль) чтобы избежать больших значений (макс 9 цифр)
- функция для подчета степеней `x`: `x_pows[i] = (x_pows[i - 1] * x) % m`
  - для того, чтобы избежать вычислений `x^l % m` при многочисленном считавании хэша подстроки
```python
def compute_hashes(s, x, m):
    n = len(s)
    h = [0] * (n + 1)
    x_pows = [1] * (n + 1)
    for i in range(1, n + 1):
        h[i] = (x * h[i - 1] + ord(s[i - 1])) % m
        x_pows[i] = (x_pows[i - 1] * x) % m
    return h, x_pows
```

### Функция `substring_hash` (Считывание хэша подстроки)
- Эта функция считает хеш подстроки `s[a:a+l]`
- происходит по формуле `h[a + l] - x^l * h[a] mod m`
- `(h[a + l] - x_pows[l] * h[a] % m + m) % m` в питоне
  - где `h[a + l]` — хеш от `s[0:a+l]`, те всей строки до последнего символа с индексом `a+l`
  - вычитается `x_pows[l] * h[a]` из `h[a + l]`: получается хэш нужной нам подстроки
  -  (h[a + l] - x_pows[l] * h[a] `% m + m) % m` - гарантирует `положительный` результат по модулю m

```python
def substring_hash(h, x_pows, a, l, m):
    return (h[a + l] - x_pows[l] * h[a] % m + m) % m
```

### main()
- генерируем 2 набора хэшей, чтобы с наибольшей вероятностью избежать коллизий
```python
h1, x1_pows = compute_hashes(s, x, m1)
h2, x2_pows = compute_hashes(s, x, m2)
```
- проходим по каждой комманде, где `a` - индекс первой подстроки, `b` - индекс второй подстроки, `l` - длина
- считваем 2 набора хэшей для 2 строк
```python
    for a, b, l in commands:
        h1_a = substring_hash(h1, x1_pows, a, l, m1)
        h1_b = substring_hash(h1, x1_pows, b, l, m1)
        h2_a = substring_hash(h2, x2_pows, a, l, m2)
        h2_b = substring_hash(h2, x2_pows, b, l, m2)
        if h1_a == h1_b and h2_a == h2_b:
            print("Yes")
        else:
            print("No")
```

Итог: временная сложность `O(n)` - 2 раза генерируем хэши (проходя циклом по строке)

---

## Задание 5
### Префикс-функции
префикс-функция такая же, как и в задании 1))))))