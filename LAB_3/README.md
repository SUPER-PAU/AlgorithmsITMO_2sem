# LAB 3

---

## Задание 1
### Задача о проверке существования пути между двумя вершинами

- `n` - количество вершин, `m` - количество ребер
- `u` - начальная вершина, `v` - конечная

считываем все пути и записываем их в `список смежности` - `graph`
```
        ==graph==
Вершина                 Пути к
0           -           -
1           -           2   4
2           -           1   3
3           -           2   4
4           -           3   1
```

Также заводим список вершин, которые мы посетили - `visited`

```python
visited = [False] * len(graph)
```

Для заполнения списка `visited` используем `DFS` - `обход в глубину`

```python
def dfs(graph, start, visited):
    visited[start] = True
    for neighbor in graph[start]:
        if not visited[neighbor]:
            dfs(graph, neighbor, visited)
```

- Начинаем с начальной вершины `u = 1` и сразу же отмечаем ее как пройденную
- Затем запускаем `DFS` от каждой вершины с которой соеденена эта из списка `graph`, т.е. от `2` и `4`
- Таким образом рекурсивно заполняется список `visited` для всех возможных вершин

Далее проверяем отмечена ли вершина `v` в списке `visited`

---


## Задание 2
### Задача подсчёта количества компонентов связности

- как и в прошлом задании создаем `graph` и `visited`

- теперь циклом проходимся по всем вершинам и запускаем dfs, если вершина не отмечена в `vistited` и увеличиваем `count`
```python
count = 0
for i in range(1, n + 1):
    if not visited[i]:
        dfs(graph, i, visited)
        count += 1
```
таким образом вершины, которые не связаны с остальными будут запускать dfs и увеличивать счетчик.

---

## Задание 3
### Задача о нахождении цикла в ориентированном графе

- как и в прошлом задании создаем `graph` и `visited`
- чтобы обнаружить цикл необходимо модернизировать `dfs` и список `visited`
- теперь `visited` булет содержать значения `0` - не посещен, `1` - посещается(dfs еще не прошел по всем связаным вершинам), `2` - полностью посещен
- в функции dfs при посещении указываем `1`, затем проходимся по связанным вершинам, и только потом указываем `2`
- Если в процессе посещения других вершин, мы наткнулись на вершину `1`, то мы нашли цикл, `has_cycle = true`
```python
has_cycle = False

def dfs(graph, start, visited):
    global has_cycle
    visited[start] = 1
    for neighbor in graph[start]:
        if visited[neighbor] == 0:
            dfs(graph, neighbor, visited)
        elif visited[neighbor] == 1:
            has_cycle = True
    visited[start] = 2
```

---

## Задание 4
### Топологическая сортировка ориентированного графа

Топологическая сортировка ориентированного ациклического графа представляет собой упорядочивание вершин таким образом, 
что для любого ребра `u -→ v`
номер вершины `u` меньше номера вершины `v`

- чтобы выполнить топологическую сортировку проверим на ацикличность данный граф (использую проверку из 3 задания)
- используем `dfs`, поставив в конце функции `result.append(start)`
- таким образом в список `result` сначала добавятся вершины, к которым ведут ребра, а затем будет вершины из которых идут эти ребра
- получится список, обратный топологической сортировке, поэтому перевернем его `result.reverse()`

```python
def dfs(graph, start, visited, result):
    visited[start] = True
    for neighbor in graph[start]:
        if not visited[neighbor]:
            dfs(graph, neighbor, visited, result)
    result.append(start)
```